// Created by rainyzwzhou on 2022/6/5.

/**
题目描述:
给定一个化学式formula（作为字符串），返回每种原子的数量。

原子总是以一个大写字母开始，接着跟随0个或任意个小写字母，表示原子的名字。

如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。例如，H2O 和 H2O2 是可行的，但 H1O2 这个表达是不可行的。

两个化学式连在一起是新的化学式。例如H2O2He3Mg4 也是化学式。

一个括号中的化学式和数字（可选择性添加）也是化学式。例如 (H2O2) 和 (H2O2)3 是化学式。

给定一个化学式，输出所有原子的数量。格式为：第一个（按字典序）原子的名子，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。

示例 1:
输入:
formula = "H2O"
输出: "H2O"
解释:
原子的数量是 {'H': 2, 'O': 1}。

示例 2:
输入:
formula = "Mg(OH)2"
输出: "H2MgO2"
解释:
原子的数量是 {'H': 2, 'Mg': 1, 'O': 2}。

示例 3:
输入:
formula = "K4(ON(SO3)2)2"
输出: "K4N2O14S4"
解释:
原子的数量是 {'K': 4, 'N': 2, 'O': 14, 'S': 4}。
注意:

所有原子的第一个字母为大写，剩余字母都是小写。
formula的长度在[1, 1000]之间。
formula只包含字母、数字和圆括号，并且题目中给定的是合法的化学式。


核心思想:
这道题我们可以利用从后往前遍历+对次数入栈的技巧，这样问题就和诸如394. 字符串解码 这种中等题目并无二致了。

具体来说，我们可以使用一个字典存储每一个原子的出现情况，字典的 key 为原子，value 为原子出现次数，最后对该字典进行排序处理输出即可。

那么字典如何生成呢？
(1)我们可以从后往前遍历，这样遇到一个大写字母我们就将其作为一个分界线。记当前位置为 s1，其右侧第一个大写字母的左侧位置记为 s2，那么 s[s1]s[s1+1]...s[s2-1] 就是一个完整的原子。接下来，我们需要知道完整的原子的出现次数。

(2)接下来需要本题的第二个技巧。那就是将数字入栈，而不是原子，（这是因为我们是从后往前遍历的）然后根据栈中存储的数字决定当前原子出现的次数。比如 K4(ON(SO3)2)2，我们从后往前面遍历，栈中开始是 [1] -> [1,2] -> [1,2,4] -> [1,2,4,12]。我们就知道 O 需要重复 12 次，接下来栈变为 [1,2,4] ，我们就知道 S 需要重复 4 次。接下来栈变为 [1,2]，我们就知道 O 和 N 分别出现 2 次，继续栈变为 [1]，不难得出 K 出现 4 次，累加即可得到字典。

**/

#include <bits/stdc++.h>

using namespace std;

class Solution {
public:
	string countOfAtoms(string formula) {
		map<string, int> mp; // 原子 和 原子的频率，这里必须要用map，因为后面的原子输出要求有序
		stack<int> st; // 存储数字
		string num, str;
		int size = formula.size(), cnt = 1;

		for (int i = size - 1; i >= 0; --i) { // 从后往前遍历
			if (isdigit(formula[i])) {
				num = formula[i] + num;
			} else if (formula[i] == ')') {
				int curCnt = num == "" ? 1 : stoi(num); // 如果num为"", 表明只有一个
				num = "";
				st.push(curCnt);
				cnt *= curCnt;
			} else if (formula[i] == '(') {
				cnt /= st.top();
				st.pop();
			} else { // 大小写字母的情况
				str += formula[i];
				if (formula[i] >= 'A' && formula[i] <= 'Z') { // 大写字母为边界
					reverse(str.begin(), str.end());
					mp[str] += (num == "" ? 1 : stoi(num)) * cnt; // 注意这里是叠加
					num = "";
					str = "";
				}
			}
		}

		string res;
		for (auto &[k, v]: mp) {
			res += k;
			if (v > 1) res += to_string(v); // 因为如果是1，就不写数字了，比如 H2O
		}
		return res;
	}
};